import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error
from scipy.optimize import curve_fit
from datetime import datetime  
from datetime import timedelta 
from scipy.optimize import fsolve
plt.style.use('seaborn')
%matplotlib inline

global_confirmed_url = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv"
global_deaths_url = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv"

US_confirmed_url = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv"
US_deaths_url = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_US.csv"

# Filter data by country
def clean_country(url1, url2):
    country = str(input("What country would you like to look at? "))
    data1 = pd.read_csv(url1)
    data2 = pd.read_csv(url2)
    choice = data1['Country/Region'] == country
    data1 = data1[choice]
    data1 = data1.iloc[:,4:]
    data1 = data1.sum()
    days = np.arange(len(data1))
    data2 = pd.read_csv(url2)
    data2 = data2[choice]
    data2 = data2.iloc[:,4:]
    data2 = data2.sum()
    days = np.arange(len(data1))
    return days, data1, data2

# Filter data by state in U.S
def clean_state(url1, url2):
    data1 = pd.read_csv(url1)
    data2 = pd.read_csv(url2)
    state = str(input("Name your state: "))
    filtER = data1['Province_State'] == state
    data1 = data1[filtER]
    data2 = data2[filtER]
    data1 = data1.iloc[:,11:]
    data2 = data2.iloc[:,11:]
    data1 = data1.sum()
    data2 = data2.sum()
    days = np.arange(len(data1))
    return days, data1, data2
 
# Reported confirmed,deaths, and recovered cases in the U.S.
# This model's main assumption is human intervention. 

# Variables: M = Carrying Capacity. k = Infection Rate. t_star = Day of inflection point.
def logistic_model(t,k,t_star,M):
    return (M)/(1+np.exp(-(t-t_star)/k))
    
def analyze(function, x, y, z):
    location = str(input("Region name for your plot: "))
    t0 = date(2020,1,22)
    tomorrow = date.today() + timedelta(days=1)
    tomorrow_date = tomorrow.strftime("%m/%d/%Y")
    delta = tomorrow - t0 # Days between tomorrow's date & 1/22/20
    
    # Function will return rate of change, t* & carrying capacity
    fit = curve_fit(function, x, y)
    param = fit[0]
    cov = fit[1]
    rate = param[0]
    t_star = param[1]
    carry_cap = param[2]
    errors = [np.sqrt(cov[i][i]) for i in [0,1,2]]
    
    mortality_rate = (z[-1])/(y[-1]) # Latest total confirmed deaths / total confirmed cases
    exp_deaths = mortality_rate * carry_cap # Expected end date deaths = MR * Carrying Capacity

    print("The current infected population is", int(y[-1]))
    print("The current mortality rate is", round((mortality_rate*100),0),"%")
    
    # Printing out the data
    t_starDate = t0 + timedelta(days= t_star)
    print("The infection rate is", round(rate,0),"with the standard error of", round(errors[0],3))
    print("The date with the highest infection rate",t_starDate, "with the standard error of", round(errors[1],3))
    print("The estimated carrying capacity is", int(carry_cap),"people with the standard error of", round(errors[2],3))
    
    # Predicting tomorrow's infections & deaths
    days_til_tomorrow = delta.days 
    exp_inf = logistic_model(days_til_tomorrow, rate, t_star, carry_cap)
    print("The estimated total number of infections for", tomorrow_date, "is", int(exp_inf), "people")
    
    tmr_exp_inf = exp_inf - y[-1]
    tmr_exp_deaths = int(mortality_rate * tmr_exp_inf)
    print("The estimated number of deaths for", tomorrow_date, "is", tmr_exp_deaths,"people")
        
    # Solving & predicting the end date
    sol = int(fsolve(lambda x : function(x,rate,t_star,carry_cap) - int(carry_cap), t_star))
    EndDate = t0 + timedelta(days= sol)
    EndDatenew = EndDate.strftime("%m/%d/%Y")
    EndDate_MR = (exp_deaths/carry_cap)*100
    
    # Plotting the rest of the logistic curve
    pred_x = list(range(max(x),sol))
    plt.figure(figsize=(6, 6))

    # Real data
    plt.scatter(x, y ,label = "Real Data", color = "r")
    z = list(x) + pred_x

    # Predicted logistic curve
    plt.scatter(days_til_tomorrow, exp_inf, linewidth = 1, color = 'k', label = "Tomorrow's Prediction")
    plt.plot(z, [logistic_model(i,rate,t_star,carry_cap) for i in z], linestyle = '--', lw = 2, 
             label = "Logistic Model")
    plt.title("COVID-19 Logistic Curve in "+ location, fontsize = 15)
    plt.legend(fontsize = 13)
    plt.xlabel("Days since Jan 22nd 2020", fontsize = 13)
    plt.ylabel("Total Number of Infected People", fontsize = 13)
    plt.ylim((min(y),carry_cap*1.1))
    plt.xticks(fontsize = 13)
    plt.yticks(fontsize = 13)
    plt.show()
    print("The expected end date is", EndDatenew)
    print("The expected number of deaths is", int(exp_deaths))
    print("The expected end date mortality rate is", round(EndDate_MR,0),"%")
    
   # Main menu function that bridges everything together
   
   def menu(global_confirmed_url,global_deaths_url, US_confirmed_url, US_deaths_url):
    selection = 0
    while selection != 3:
        print("1. Analyze a Country")
        print("2. Analyze a U.S region")
        print("3. Quit")
        selection = int(input("Please enter a selection: "))
        if selection == 1:
            days, country_confirmed, country_deaths = clean_country(global_confirmed_url,global_deaths_url)
            analyze(logistic_model, days, country_confirmed, country_deaths)
            break
        elif selection == 2:
            days2, state_confirmed, state_deaths = clean_state(US_confirmed_url, US_deaths_url)
            analyze(logistic_model, days2, state_confirmed, state_deaths)
            break
        elif selection == 3:
            print("Goodbye!")
   
   # Calling the function
   
   menu(global_confirmed_url, global_deaths_url, US_confirmed_url, US_deaths_url)
            break
