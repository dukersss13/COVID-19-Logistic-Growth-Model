import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error
from scipy.optimize import curve_fit
from datetime import datetime  
from datetime import timedelta 
from scipy.optimize import fsolve
plt.style.use('seaborn')
%matplotlib inline

# The following data sets will be updated daily. (Source: CSSE John Hopkins University).
global_confirmed_url = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv"
global_deaths_url = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv"

US_confirmed_url = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv"
US_deaths_url = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_US.csv"

# Filter data by country
def clean_country(url1, url2):
    country = str(input("Select a country: "))
    data1 = pd.read_csv(url1)
    data2 = pd.read_csv(url2)
    choice = data1['Country/Region'] == country
    data1 = data1[choice]
    data1 = data1.iloc[:,4:]
    data1 = data1.sum()
    days = np.arange(len(data1))
    data2 = pd.read_csv(url2)
    data2 = data2[choice]
    data2 = data2.iloc[:,4:]
    data2 = data2.sum()
    days = np.arange(len(data1))
    return days, data1, data2

# Filter data by state in U.S
def clean_state(url1, url2):
    data1 = pd.read_csv(url1)
    data2 = pd.read_csv(url2)
    state = str(input("Select a US state/region: "))
    filtER = data1['Province_State'] == state
    data1 = data1[filtER]
    data2 = data2[filtER]
    data1 = data1.iloc[:,11:]
    data2 = data2.iloc[:,11:]
    data1 = data1.sum()
    data2 = data2.sum()
    days = np.arange(len(data1))
    return days, data1, data2
 
# Reported confirmed,deaths, and recovered cases in the U.S.
# This model's main assumption is human intervention and the recovered/removed population can no longer infect others.

# Variables: M = Carrying Capacity. k = Infection Rate. t_star = Day of inflection point.
def logistic_model(t,k,t_star,M):
    return (M)/(1+np.exp(-(t-t_star)/k))
    
# This function calculates the % error from the predictions made the previous day.
def error(function, x, y, z):
    t0 = date(2020,1,22)
    today = date.today()
    delta = today - t0
    fit = curve_fit(function, x[:-2], y[:-2])
    param = fit[0]
    cov = fit[1]
    rate = param[0]
    t_star = param[1]
    carry_cap = param[2]
    errors = [np.sqrt(cov[i][i]) for i in [0,1,2]]
    
    mortality_rate = (z[-2])/(y[-2]) # Latest total confirmed deaths / total confirmed cases
    predicted_deaths = mortality_rate * carry_cap
    
    t_starDate = t0 + timedelta(days = t_star)
    days_til_today = delta.days 
    pred_inf = logistic_model(days_til_today, rate, t_star, carry_cap)
    
    inf_error = abs((pred_inf - y[-1])/y[-1]) * 100
    deaths_error = abs((predicted_deaths - z[-1])/ z[-1])
    return inf_error, deaths_error

# This function is very similar to the one above, but does the computation based on today's updated data & make predictions.
 
def analyze(function, x, y, z, location):
    t0 = date(2020,1,22)
    tomorrow = date.today() + timedelta(days=1)
    tomorrow_date = tomorrow.strftime("%m/%d/%Y")
    delta = tomorrow - t0 # Days between tomorrow's date & 1/22/20
    
    # Function will return rate of change, t* & carrying capacity
    fit = curve_fit(function, x, y)
    param = fit[0]
    cov = fit[1]
    rate = param[0]
    t_star = param[1]
    carry_cap = param[2]
    errors = [np.sqrt(cov[i][i]) for i in [0,1,2]]
    
    mortality_rate = (z[-1])/(y[-1]) # Latest total confirmed deaths / total confirmed cases
    exp_deaths = mortality_rate * carry_cap # Expected end date deaths = MR * Carrying Capacity

    print("The current infected population is", int(y[-1]))
    print("The current mortality rate is", round((mortality_rate*100),0),"%")
    
    # Printing out the data
    t_starDate = t0 + timedelta(days= t_star)
    print("The infection rate is", round(rate,0), "with the standard error of", round(errors[0],3))
    print("The date with the highest infection rate", t_starDate)
    print("The estimated carrying capacity is", int(carry_cap), "+/-", round(errors[2],0),"people")
    
    # Calculating the percentage error from yesterday's predictions
    inf_error, deaths_error = error(function, x, y, z)
    
    # Predicting tomorrow's infections & deaths
    days_til_tomorrow = delta.days 
    exp_inf = logistic_model(days_til_tomorrow, rate, t_star, carry_cap)
    print("The estimated total number of infections for", tomorrow_date, "is", int(exp_inf), "+/-", 
          int(inf_error*exp_inf), "people")
    
    tmr_exp_inf = exp_inf - y[-1]
    tmr_exp_deaths = int(mortality_rate * tmr_exp_inf)
    print("The estimated number of deaths for", tomorrow_date, "is", tmr_exp_deaths,"+/-", 
          int(deaths_error*tmr_exp_deaths),"people")
    
    # Plotting the logistic curve
    plt.figure(figsize=(6, 6))
    
    # Real data
    plt.scatter(x, y ,label = "Real Data", color = "r")
    # Predicted logistic curve
    plt.scatter(days_til_tomorrow, exp_inf, linewidth = 1, color = 'k', label = "Tomorrow's Prediction")
    
    # Solving & predicting the end date
    sol = int(fsolve(lambda x : function(x,rate,t_star,carry_cap) - int(carry_cap), t_star))
    EndDate = t0 + timedelta(days = sol)
    EndDatenew = EndDate.strftime("%m/%d/%Y")
    EndDate_MR = (exp_deaths/carry_cap)*100
    
    pred_x = list(range(max(x),sol))
    z = list(x) + pred_x
    plt.plot(z, [logistic_model(i,rate,t_star,carry_cap) for i in z], linestyle = '--', lw = 2, label = "Logistic Model")
    plt.title("COVID-19 Logistic Curve in "+ location, fontsize = 15)
    plt.legend(fontsize = 13)
    plt.xlabel("Days since Jan 22nd 2020", fontsize = 13)
    plt.ylabel("Total Number of Infected People", fontsize = 13)
    plt.ylim((min(y),carry_cap*1.1))
    plt.xticks(fontsize = 13)
    plt.yticks(fontsize = 13)
    plt.show()
    print("The expected end date is", EndDatenew)
    print("The expected number of deaths is", int(exp_deaths))
    print("The expected end date mortality rate is", round(EndDate_MR,0),"%")
    
   # Main menu function that bridges everything together
   
   def menu(global_confirmed_url,global_deaths_url, US_confirmed_url, US_deaths_url):
    selection = 0
    while selection != 3:
        print("1. Analyze a Country")
        print("2. Analyze a U.S state/region")
        print("3. Quit")
        selection = int(input("Please enter a selection: "))
        if selection == 1:
            days, country_confirmed, country_deaths = clean_country(global_confirmed_url,global_deaths_url)
            analyze(logistic_model, days, country_confirmed, country_deaths)
        elif selection == 2:
            days2, state_confirmed, state_deaths = clean_state(US_confirmed_url, US_deaths_url)
            analyze(logistic_model, days2, state_confirmed, state_deaths)
        elif selection == 3:
            print("Goodbye & stay healthy!")
            break
            
   # Calling the function
   
   menu(global_confirmed_url, global_deaths_url, US_confirmed_url, US_deaths_url)
